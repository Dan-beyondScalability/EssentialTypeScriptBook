# Appendix: Syntax Examples

## ECMAScript 6 Features

### Optional/Default parameters

```
// "final" and "interval" parameters are optional.
// If omitted, they will be defaulted to 0 and 1 (respectively)
function countdown(initial, final = 0, interval = 1) {
  // Countdown logic
}

// You can then call the method with one, two, or three parameters:
countdown(10)       // -> countdown(10, 0, 1)
countdown(10, -10)  // -> countdown(10, -10, 1)
countdown(10, -10, 5) 
```

### Template strings

```
var name = 'Ada Lovelace';
var birthDate = new Date(1815, 12, 10);

var template = `
    <div class="user">
      <p class='name'>${name}</p>
      <p>
        <span class='birthDate'>${birthDate.toDateString()}</span>
        <span class='age'>
          ${ Math.floor( (new Date() - birthDate) / 31536000000) } 
          years old
        </span>
      </p>
    </div>
`;
```

### `let` and `const`

#### `let`
Use `let` anywhere that you previously used `var`, especially in places where you wouldn't expect variables to creep out of their scope, such as:

	for(var x = 0; x <= 5; x++) {
	    var counter = x;
	}
	
	console.log(counter); // Prints 5... how odd!

Instead, with `let`:

	for(let x = 0; x <= 5; x++) {
	    let counter = x;
	}
	
	console.log(counter); // Browser says "I don't know about 'counter'" (like you'd expect!)

#### `const`

  for(let x = 0; x < 5; x++) {
      const counter = x;  // Assign a constant to an initial value...
      counter = 1;        // Try to reassign and get a runtime error, "can't reassign constant variable"
  }

### For..of loops

Use `for`/`of` anywhere that you previously would have used `for`/`in`:

  var array = [ "Pick up drycleaning",  "Clean Batcave", "Save Gotham" ];

  // Old way:
  for(var index in array) {
      var value = array[index];
      console.log(value);
  }

  // New way:
  for(var value of array) {
      console.log(value);
  }


### Arrow Functions

Use arrow functions *almost* anywhere that you would have used an anonymous function:

  var todos = [ 
    { name: "Pick up drycleaning", completed: false },
    { name: "Clean Batcave", completed: true },
    { name: "Save Gotham", completed: false }
  ];
  
  // Old way:
  var completed = todos.filter(function(todo) { 
    return todo.completed;
  });
  
  // New way:
  var completed = todos.filter((todo) => { return todo.completed; });

  // Of course, the parentheses around the parameter list are optional if there is only one parameter:
  var completed = todos.filter(todo => { return todo.completed; });

  // And if you've only got one line/expression, you don't even need the brackets.
  // (Bonus: the return value is the result of the expression!)
  var completed = todos.filter(todo => todo.completed);


__Caveat: the `this` keyword__

The only time arrow functions actually change the functionality of a function is by saving a reference to the `this` keyword.  Often, this is exactly what you want to happen!

  function CounterButton(element) {
  
    this.counter = 0;
  
    element.addEventListener('click', function() {
      this.counter += 1;  // Doesn't work  :(
    })
  
    // Works great!
    element.addEventListener('click', () => this.counter += 1);
    
  }

### Destructuring

Assigning a set of variables from a simple array:

  var array = [123, "Pick up drycleaning", false];
  var [id, title, completed] = array;   // ->  id = 123, title = "Pick up drycleaning", completed = false
  
Swapping the values of variables:

  var a = 1;
  var b = 5;
  
  [a, b] = [b, a];  // -> a = 5, b = 1

Assigning a set of variables from an object:

  var todo = { 
      id: 123, 
      title: "Pick up drycleaning", 
      completed: false
  };
  
  var { id, title, completed } = todo;   // ->  id = 123, title = "Pick up drycleaning", completed = false

Assigning a set of variables from an object where the target variable name is different from the object property name:

  var { completed: isCompleted, title, id } = todo;   // ->  id = 123, title = "Pick up drycleaning", isCompleted = false

You can even set default values:

  var todo { name: 'Pick up drycleaning' };
  var { name, isCompleted = false } = todo;   // -> name = 'Pick up drycleaning', isCompleted = false

And, perhaps the coolest usage: destructing a function parameter object to a set of variables in the function (with default values!):

  function countdown({ initial, final: final = 0, interval: interval = 1, initial: current }) {
    // Countdown logic...
  }
  
  countdown({ initial: 20 })                            // -> initial = 20, final = 0, interval = 1, current = 20
  countdown({ initial: 20, final: -10 })                // -> initial = 20, final = -10, interval = 1, current = 20
  countdown({ initial: 20, final: -10, interval: 5 })   // -> initial = 20, final = -10, interval = 5, current = 20

### The spread operator

Use the spread operator (`...`) to accept any number of function parameters into a single array variable:

  function add(...values) {
    return values.reduce( (a, b) => a + b );
  }
  
The function can still have other parameters, as long as the spread parameter comes last:

  function calculate(action, ...values) {
    switch (action) {
      
      case 'add':
        return values.reduce( (a, b) => a + b );
        
      case 'subtract':
        return values.reduce( (a, b) => a - b );
        
      default:
        throw `Unknown action ${action}!`;
    }
  }
  
Or, use it to concatenate arrays together:

  var source = [ 3, 4, 5 ];
  var target = [ 1, 2, ...source , 6, 7 ];  // -> [ 1, 2, 3, 4, 5, 6, 7 ]
  

### Computed properties

Define property names on the fly:

  const osPrefix = 'os_'; 
  
  var support = {
      [osPrefix + 'Windows']: false,
      [osPrefix + 'iOS']: true,
      [osPrefix + 'Android']: true,
  };
  
  support // -> { os_Windows: false, os_iOS: true, os_Android: true }


## Fundamentals

### Specifying a type
*[TBD]*

### Union Types
*[TBD]*

### Function overloads
*[TBD]*


## Custom Types

### Interface
*[TBD]*

### Enum
*[TBD]*

### Anonymous type
*[TBD]*


## Classes

### Basic Class
*[TBD]*

### Inheritance
*[TBD]*

### Abstract base class
*[TBD]*

### Implementing an interface
*[TBD]*


## Generics

### Generic function
*[TBD]*

### Generic class
*[TBD]*

### Generic constraints
*[TBD]*


## Modules

### Internal Modules (Namespaces)
*[TBD]*

### External Modules (exports)
*[TBD]*

### Import with require
*[TBD]*

### Import with ECMAScript `import` keyword
*[TBD]*


## Decorators

### Method Decorator
*[TBD]*

### Class Decorator
*[TBD]*

### Property Decorator
*[TBD]*

### Decorator Factory
*[TBD]*
